doctype html
html(lang="en")
  head
    meta(charset="UTF-8")
    meta(name="viewport", content="width=device-width, initial-scale=1.0")
    title Myth Journey – Page 1

    // Fonts
    link(rel="preconnect", href="https://fonts.googleapis.com")
    link(rel="preconnect", href="https://fonts.gstatic.com", crossorigin)
    link(
      href="https://fonts.googleapis.com/css2?family=Work+Sans:wght@100..900&display=swap",
      rel="stylesheet"
    )

    // Main CSS
    link(rel="stylesheet", href="assets/css/style.css")

    // Font Awesome
    link(
      rel="stylesheet",
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    )

    // GSAP
    script(src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js")

    style.
      .logo-container.fixed {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 999;
      }

  body.page1
    // =======================
    // LOGO CONTAINER
    // =======================
    .logo-container
      img.logo-trigger.logo1(src="/images/red-arrow-logo.png", alt="Red Logo")

    // =======================
    // OVERLAY
    // =======================
    .overlay
      .outer
        .top-icon.arrow
          img(src="/images/menu-arrow.png", alt="Close")

        .stage#stage
          .carousel#carousel
            each item, index in menuItems
              - const isMain = index === 0
              .item(
                class=isMain ? 'main' : 'side'
                data-route=item.data.route[0].text
                data-label=item.data.label.map(b => b.text).join(' ')
              )
                span #{String(index + 1).padStart(2, '0')}
                each block in item.data.label
                  | #{block.text}
                  br

        .social-icons
          span
            img(src="/images/facebook-icon.png", alt="Facebook")
          span
            img(src="/images/linkdin-icon.png", alt="LinkedIn")
          span
            img(src="/images/instagram-icon.png", alt="Instagram")

    script.
      // =======================
      // CLICK TO MOVE THE SLIDER
      // =======================
      const carousel = document.getElementById('carousel');
      const items = carousel.querySelectorAll('.item');

      const sensitivity = 0.25;
      const itemCount = items.length;
      const degreePerItem = 360 / itemCount;

      let currentRotation = 0;

      // Helper function to update the highlight on clicked item
      function updateHighlight(rotation) {
        const normalized = ((rotation % 360) + 360) % 360;
        const centerIndex = Math.round(normalized / degreePerItem) % itemCount;

        items.forEach((item, index) => {
          if (index === (itemCount - centerIndex) % itemCount) {
            item.classList.add('main');
            item.classList.remove('side');
          } else {
            item.classList.add('side');
            item.classList.remove('main');
          }
        });
      }

      // Function to find the center item based on the rotation
      function getCenterItem(rotation) {
        const normalizedRotation = (rotation % 360 + 360) % 360;
        const centerIndex = Math.round(normalizedRotation / degreePerItem) % itemCount;
        return items[centerIndex];
      }

      // Function to check if an item is currently centered
      function isItemCentered(item) {
        return item.classList.contains('main');
      }

      // Click event listener for each item
      document.querySelectorAll('.carousel .item').forEach(item => {
        item.addEventListener('click', (e) => {
          const route = item.dataset.route;
          const label = item.dataset.label;

          // Check if the clicked item is already centered BEFORE updating
          const isCentered = isItemCentered(item);

          // Get the clicked item's index
          const itemIndex = Array.from(items).indexOf(item);

          // Calculate the absolute rotation needed to center the clicked item
          // Based on updateHighlight logic: when rotation = centerIndex * degreePerItem,
          // the item at index (itemCount - centerIndex) % itemCount is centered
          // So to center itemIndex, we need: centerIndex = (itemCount - itemIndex) % itemCount
          const targetCenterIndex = (itemCount - itemIndex) % itemCount;
          const absoluteTargetRotation = targetCenterIndex * degreePerItem;

          // Normalize current rotation to 0-360 range
          const normalizedCurrent = ((currentRotation % 360) + 360) % 360;

          // Find the shortest rotation path from current to target
          // Try both directions and pick the shorter one
          let rotationDelta1 = absoluteTargetRotation - normalizedCurrent;
          let rotationDelta2 = rotationDelta1 > 0 ? rotationDelta1 - 360 : rotationDelta1 + 360;
          
          // Choose the shorter path
          let rotationDelta = Math.abs(rotationDelta1) < Math.abs(rotationDelta2) ? rotationDelta1 : rotationDelta2;

          // Calculate the new target rotation (add delta to current, not normalized)
          const targetRotation = currentRotation + rotationDelta;

          // Only navigate if the item was already centered
          if (isCentered) {
            console.log('NAVIGATING →', label);
            // Apply the rotation with smooth transition
            carousel.style.transition = 'transform 0.8s cubic-bezier(0.23,1,0.32,1)';
            carousel.style.transform = `rotateY(${targetRotation}deg)`;

            // Update the highlighted item
            updateHighlight(targetRotation);

            // Update current rotation
            currentRotation = targetRotation;

            // Navigate after a short delay to allow the transition to start
            setTimeout(() => {
              window.location.replace(
                `/loading?to=${encodeURIComponent(route)}&label=${encodeURIComponent(label)}`
              );
            }, 100);
          } else {
            console.log('SCROLLING TO CENTER →', label);
            // Item is not centered, just scroll it to center (no navigation)
            carousel.style.transition = 'transform 0.8s cubic-bezier(0.23,1,0.32,1)';
            carousel.style.transform = `rotateY(${targetRotation}deg)`;

            // Update the highlighted item
            updateHighlight(targetRotation);

            // Update current rotation
            currentRotation = targetRotation;
          }
        });
      });

      // Initialize the carousel to show the first item
      carousel.style.transform = `rotateY(0deg)`;
      updateHighlight(0);

      // =======================
      // OVERLAY OPEN / CLOSE
      // =======================
      const overlay = document.querySelector('.overlay');
      const logo = document.querySelector('.logo1');
      const arrow = document.querySelector('.arrow img');

      gsap.set(overlay, { y: "100%", display: "none" });

      // Get progress bar wrapper (used on portfolio page)
      const progressBarWrapper = document.querySelector('.progress-bar-wrapper');

      logo.addEventListener('click', () => {
        overlay.style.display = "block";
        gsap.to(overlay, { y: 0, duration: 1, ease: "power4.out" });
        // Hide progress bar when menu opens
        if (progressBarWrapper) {
          progressBarWrapper.style.display = "none";
        }
      });

      arrow.addEventListener('click', () => {
        gsap.to(overlay, {
          y: "100%",
          duration: 1,
          ease: "power4.in",
          onComplete: () => {
            overlay.style.display = "none";
            // Show progress bar when menu closes
            if (progressBarWrapper) {
              progressBarWrapper.style.display = "block";
            }
          }
        });
      });

      // =======================
      // LOGO SCROLL SHOW / HIDE + FIXED POSITION
      // =======================
      const logoContainer = document.querySelector('.logo-container');

      let lastScrollY = window.scrollY;
      const scrollThreshold = 10;

      gsap.set(logoContainer, { y: 0, opacity: 1 });

      window.addEventListener('scroll', () => {
        const currentScrollY = window.scrollY;

        if (Math.abs(currentScrollY - lastScrollY) < scrollThreshold) return;

        if (currentScrollY > lastScrollY && currentScrollY > 50) {
          logoContainer.classList.remove('fixed');
          gsap.to(logoContainer, {
            y: -100,
            opacity: 0,
            duration: 0.4,
            ease: "power3.out"
          });
        } else {
          logoContainer.classList.add('fixed');
          gsap.to(logoContainer, {
            y: 0,
            opacity: 1,
            duration: 0.4,
            ease: "power3.out"
          });
        }

        lastScrollY = currentScrollY;
      });